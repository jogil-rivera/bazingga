import random

random_float = random.random()
# .random() is for any number (float) between 0 - 1.

print(random_float)

random_integer = random.randint(0, 9)
# .randint(x, y) is for any integer between the (start, stop) boundaries provided to randint. the lower of the two
#   numbers has to start. the passageway is (a, b+1), so in this instance, 9 is available as an outcome of running this
#   line of code.

print(random_integer)

# reference: The Programming Portal channel, YouTube, "Random number generator in Python," video (TPP).
# From https://www.youtube.com/watch?v=CasqhmeopnU

# "The random number or data generated by Pythonâ€™s random module is not truly random; it is pseudo-random(it is PRNG),
#   i.e., deterministic. (pynative)"
# "The seed value is very significant in computer security to pseudo-randomly generate a secure secret encryption
#   key. (pynative)"

random.seed(a=None, version=2)
# Syntax; "It is the seed value. If the a is None, then by default, current system time is used.
#   If the operating system provides randomness sources, they are used instead of the system time.
#   For example, On windows, the os.urandom() internally uses CryptGenRandom() to generate random data.
#   If you pass a seed value in the form of an integer, it is used as it is. (pynative)"



# reference: From https://pynative.com/python-random-seed/
# (pynative)

# i looked up os.urandom() as deterministic, on Google, and stackoverflow gave me this, as the top answer.
# "You can read up on the distinction of cryptographically secure RNG in this fantastic answer over at Crypto.SE.
#   The main distinction between random and the system RNG like urandom is one of use cases. random implements
#   deterministic PRNGs. There are scenarios where you want exactly those. For instance when you have an algorithm with
#   a random element which you want to test, and you need those tests to be repeatable. In that case you want a
#   deterministic PRNG which you can seed.
# urandom.() on the other hand cannot be seeded and draws its source of entropy from many unpredictable sources, making
#   it more random.
# True random is something else yet and you'd need a physical source of randomness like something that measures atomic
#   decay; that is truly random in the physical sense, but usually overkill for most applications." -

# i took the advice to glimpse at Crypto.SE, and it gave me a bunch of nerdy definitions, over-conceptualizing the
#   word, "random." what was useful?
# "There is no known method to predict decay so, yes, that is by definition cryptographically secure. Such things are
#   considered true randomness, as opposed to the pseudo-randomness that we generate with our pseudo-random number
#   generators (algorithms).
# The caveat is that you have to use the true random source properly. For example, if one particle decays (on average)
#   every 30 nanoseconds and you write down the current time every time it happens, this number is not very random
#   because the time is ever-increasing and the next event will almost certainly be less than X nanoseconds after the
#   previous one. An attacker can guess the few possible values between 0 and X. Only the timing variation from each
#   decay event can be used, for example by taking the last digit of the nanosecond in which the particle decayed. That
#   would give a uniform distribution from 0 through 9, so a couple bits of entropy/randomness... if and only if your
#   clock is precise to that nanosecond and has no interruptions that an attacker could learn of, which might be hard
#   to verify.
# So while it's truly random, designing methods to extract the entropy from such sources is not necessarily intuitive
#   or easy. - Luc