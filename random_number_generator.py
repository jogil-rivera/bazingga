import random

random_float = random.random()
# .random() is for any number (float) between 0 - 1.

print(random_float)

random_integer = random.randint(0, 9)
# .randint(x, y) is for any integer between the (start, stop) boundaries provided to randint. the lower of the two
#   numbers has to start. the passageway is (a, b+1), so in this instance, 9 is available as an outcome of running this
#   line of code.

print(random_integer)
# will either print 0, 1, 2, 3, 4, 5, 6, 7, 8, or 9. depending on the os's current state.

random_number = random.randrange(10, 20, 2)
print(random_number)
# will print an even number between 10-20. either 10, 12, 14, 16, or 18.
# .randrange() = .randint() + step count <as a filter>
# however, .randrange(start, end, step) will lead up to the end, never resulting in it.
# .randint(x, y) can produce y.

random_float = random.uniform(50, 70)
print(random_float)
# will print any float between 50, 70

# i wondered whether or not it would ever promote 70. stackoverflow gave me this:

# "Quoting the random.random() documentation:

# Return the next random floating point number in the range [0.0, 1.0).

# The notation [..., ...) means that the first value is part of all possible values, but the second one is not.
#   random.random() will at most produce values very close to 1.0." - Martijn Pieters♦, edited by wim


# From: https://stackoverflow.com/questions/58241868/can-random-uniform0-1-ever-generate-0-or-1

# in theory, our random.uniform(50, 70) example, could produce 50, but due to the rules of .random(), we will never
#   get next to return the NEXT.

# back to (TPP)

numList = random.sample(range(150, 250), 15)
print(numList)
# will print 15 random numbers, between 150 and 250, including 150, but never 250.
# for some reason, ranges don't recognize upper limits as possible outcomes.

num_list = [1, 2, 3, 4, 5]
random.shuffle(num_list)
print(num_list)
# will randomly sort the numbers, provided within the list.

print(random.choice(num_list))
# will randomly choose one element from the provided list.

# reference: The Programming Portal channel, YouTube, "Random number generator in Python," video. -> (TPP)
#   From https://www.youtube.com/watch?v=CasqhmeopnU

# so... i looked into RNG a little.

# "The random number or data generated by Python’s random module is not truly random; it is pseudo-random(it is PRNG),
#   i.e., deterministic. (pynative)"
# "The seed value is very significant in computer security to pseudo-randomly generate a secure secret encryption
#   key. (pynative)"

random.seed(a=None, version=2)
# Syntax; "It is the seed value. If the a is None, then by default, current system time is used.
#   If the operating system provides randomness sources, they are used instead of the system time.
#   For example, On windows, the os.urandom() internally uses CryptGenRandom() to generate random data.
#   If you pass a seed value in the form of an integer, it is used as it is. (pynative)"


# reference: From https://pynative.com/python-random-seed/ -> (pynative)
#   i know bibliographies belong on the very bottom, but readabilty is more coercive this way.

# i looked up os.urandom() as "deterministic," on Google, and stackoverflow gave me this, as the top answer.

# "You can read up on the distinction of cryptographically secure RNG in this fantastic answer over at Crypto.SE.
#   The main distinction between random and the system RNG like urandom is one of use cases. random implements
#   deterministic PRNGs. There are scenarios where you want exactly those. For instance when you have an algorithm with
#   a random element which you want to test, and you need those tests to be repeatable. In that case you want a
#   deterministic PRNG which you can seed.
# urandom.() on the other hand cannot be seeded and draws its source of entropy from many unpredictable sources, making
#   it more random.
# True random is something else yet and you'd need a physical source of randomness like something that measures atomic
#   decay; that is truly random in the physical sense, but usually overkill for most applications." - deceze♦


# From https://stackoverflow.com/questions/47514695/whats-the-difference-between-os-urandom-and-random#:~:text=urandom%20on%20the%20other%20hand,sources%2C%20making%20it%20more%20random.

# i took the advice to glimpse at Crypto.SE, and it gave me a bunch of nerdy definitions, over-conceptualizing the
#   word, "random." what was useful?

# "There is no known method to predict decay so, yes, that is by definition cryptographically secure. Such things are
#   considered true randomness, as opposed to the pseudo-randomness that we generate with our pseudo-random number
#   generators (algorithms).
# The caveat is that you have to use the true random source properly. For example, if one particle decays (on average)
#   every 30 nanoseconds and you write down the current time every time it happens, this number is not very random
#   because the time is ever-increasing and the next event will almost certainly be less than X nanoseconds after the
#   previous one. An attacker can guess the few possible values between 0 and X. Only the timing variation from each
#   decay event can be used, for example by taking the last digit of the nanosecond in which the particle decayed. That
#   would give a uniform distribution from 0 through 9, so a couple bits of entropy/randomness... if and only if your
#   clock is precise to that nanosecond and has no interruptions that an attacker could learn of, which might be hard
#   to verify.
# So while it's truly random, designing methods to extract the entropy from such sources is not necessarily intuitive
#   or easy. - Luc


# From https://crypto.stackexchange.com/questions/39186/what-does-it-mean-for-a-random-number-generator-to-be-cryptographically-secure/39188#39188

# back up to stackoverflow, there was also this little gem, from DoesData.
# "Python 3.6 introduces the new secrets module"

# following their hyperlink led me to, https://docs.python.org/3/library/secrets.html
# some of the highlights here, are as follows:

# "In particular, secrets should be used in preference to the default pseudo-random number generator in the random
#   module, which is designed for modelling and simulation, not security or cryptography...

# To be secure against brute-force attacks, tokens need to have sufficient randomness. Unfortunately, what is
#   considered sufficient will necessarily increase as computers get more powerful and able to make more guesses in a
#   shorter period. As of 2015, it is believed that 32 bytes (256 bits) of randomness is sufficient for the typical
#   use-case expected for the secrets module."

# So, it basically provides recipes to format your own personal passwords, to be kept on drive. but, given that this is
#   all hashed out, on a dynamic language case, there are programs out there that can write up everything commanded, in
#   reverse. a good rule of thumb, when it comes to coding. if you can't see it in binary, you're not really in control.
# We're all standing on someone else's life's work.

# back up to pynative's .seed() tutorial:

random.seed(a=None, version=2)
# Syntax; "version: If the version is set to 2 by default, str, bytes, or bytearray object gets converted to an int,
#   and all of its bits are used. (pynative)"

# The rest of this page, explains that random function should be sequenced together, in order to form a more complex
#   algorithm.

# random.seed() example:

import random

print('Random number with seed 30')
for i in range(3):
    # Random number with seed 30
    random.seed(30)
    print(random.randint(25, 50))

# Output:
# Random number with seed 30
# 42
# 42
# 42
# (pynative)

# system time .seed() example:

import random
from datetime import datetime

# Random number with system time
#random.seed(datetime.now())
print("Random Number", random.randint(25, 50))
# Output 50
# (pynative)
# it should print -> Random Number 50

# alternative to custom .seed(), in order to save the outcome.

import random
import sys

# create a seed
seed_value = random.randrange(sys.maxsize)
# save this seed somewhere. So if you like the result you can use this seed to reproduce it
print('Seed value:', seed_value)
# Output 4542355562136458828
#(pynative)
# it should print -> Seed value: 4542355562136458828

# Now, Seed the random number generator
random.seed(seed_value)
num = random.randint(10, 500)
print("Random Number", num)
# Output 404
#(pynative)
# it should print -> Random Number 404
# this means that random.randint(10, 500) seeded with 4542355562136458828, gives us 404, followed by a deterministic
#   number set.

# .seed() with .randrange()

import random

# Random seed with randrange
random.seed(350)
print(random.randrange(300, 500))
# output 336

random.seed(350)
print(random.randrange(300, 500))
# Output 336
# (pynative)
# same seed = same species

# .seed() with .choice()

import random
names = ["Alex", "Emma", "Kelly", "Scott", "Jessa"]

random.seed(50)
random_item = random.choice(names)
print ("First random name from list ", random_item)
# output scott

random.seed(50)
random_item = random.choice(names)
print ("Second random name from list ", random_item)
# output Scott
# (pynative)
# it should print out -> First random name from list Scott
# then, -> Second random name from list Scott

# .seed() with .sample(sample_list, #_of_samples_taken)

import random

# using random.seed() and random.sample() together
fruit_list = ["Apple", "Mango", "Banana", "Apricot", "Cherries", "Grape", "Kiwi"]

random.seed(3)
sample_list = random.sample(fruit_list, 3)
print("First sample fruit list ", sample_list)
# Output ['Mango', 'Cherries', 'Grape']

random.seed(3)
sample_list = random.sample(fruit_list, 3)
print("Second sample fruit list ", sample_list)
# output ['Mango', 'Cherries', 'Grape']
# (pynative)
# it should print out -> First sample fruit list ['Mango, 'Cherries, 'Grape']
# then, -> Second sample fruit list ['Mango', 'Cherries', 'Grape']

# .seed() with .shuffle(list)

import random

numbers = [10, 20, 30, 40, 50, 60]
print("Original list: ", numbers)
random.seed(4)
random.shuffle(numbers)
print("Shuffled list ", numbers)
# Output [40, 60, 50, 10, 30, 20]

random.seed(4)
random.shuffle(numbers)
print("Reshuffled list ", numbers)
# Output [40, 60, 50, 10, 30, 20]
# (pynative)
# it should read -> Original list: [10, 20, 30, 40, 50, 60]
# followed by, -> Shuffled list [40, 60, 50, 10, 30, 20]
# then, -> Reshuffled list [40, 60, 50, 10, 30, 20]
# Shuffled list and Reshuffled list are the same output, because the seed is consistent.

# reference: From https://pynative.com/python-random-seed/ -> (pynative)

# following, once more, from order of appearance:

# reference: The Programming Portal channel, YouTube, "Random number generator in Python," video. -> (TPP)
#   From https://www.youtube.com/watch?v=CasqhmeopnU
# reference: https://stackoverflow.com/questions/58241868/can-random-uniform0-1-ever-generate-0-or-1
# reference: https://stackoverflow.com/questions/47514695/whats-the-difference-between-os-urandom-and-random#:~:text=urandom%20on%20the%20other%20hand,sources%2C%20making%20it%20more%20random.
# reference: https://crypto.stackexchange.com/questions/39186/what-does-it-mean-for-a-random-number-generator-to-be-cryptographically-secure/39188#39188

# i tried making a password.

import random
import sys

val = random.randrange(sys.maxsize)
print('a seed: ', val)

list = []

for i in range(0,random.randrange(1,4)):
    list.append(val)
    break

val = random.randrange(sys.maxsize)

for i in range(0,random.randrange(1,4)):
    list.append(val)
    break

val = random.randrange(sys.maxsize)

for i in range(0,random.randrange(1,4)):
    list.append(val)
    break

print('this is a list of seeds: ', list, end = 2 * "\n")

print('i\'m picking one: ', random.choice(list))

x = random.sample(list, 2)

print('nvm, i want two, just incase (doesn\'t have to be the one i just chose): ', x, end = 2 * "\n")

def whatis(z):
    zed = 0
    random.seed(val)
    # y needs a new seed, val is already assigned to rr(sys.maxsize)
    y = random.uniform(1,1000)
    # b/c floats are the scary ones
    print('"a thick number": ', y, end = 2 * "\n")
    print('those two, from earlier, added together: ', sum(x))
    print('that summation, multiplied by, "a thick number": ', sum(x) * y)
    zed = int(sum(x) * y)
    return int(zed)

zed = whatis(0)

trundle = str(zed)
print('this is the seed, as a result of 3 seeds, summate 2 at random, multiply by a uniform, turned into a string: ',
      trundle)

maokai = {}
for i in trundle:
    sh = int(i)
    maokai.setdefault('_', [])
    maokai['_'].append(sh)

def nicki(hi):
    print('next up, recursions... here\'s my password: ', end = "")
    for j in maokai.values():
        for k in j:
            if k == 0:
                print('h', end = "")
            elif k == 1:
                print('e', end = "")
            elif k == 2:
                print('a', end = "")
            elif k == 3:
                print('t', end = "")
            elif k == 4:
                print('i', end = "")
            elif k == 5:
                print('n', end = "")
            elif k == 6:
                print('d', end = "")
            elif k == 7:
                print('x', end = "")
            elif k == 8:
                print('o', end = "")
            elif k == 9:
                print('s', end = "")
            else:
                None
nicki(1)