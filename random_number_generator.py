import random

random_float = random.random()
# .random() is for any number (float) between 0 - 1.

print(random_float)

random_integer = random.randint(0, 9)
# .randint(x, y) is for any integer between the (start, stop) boundaries provided to randint. the lower of the two
#   numbers has to start. the passageway is (a, b+1), so in this instance, 9 is available as an outcome of running this
#   line of code.

print(random_integer)

# reference: The Programming Portal channel, YouTube, "Random number generator in Python," video. -> (TPP)
# From https://www.youtube.com/watch?v=CasqhmeopnU

# so... i looked into it a little.

# "The random number or data generated by Python’s random module is not truly random; it is pseudo-random(it is PRNG),
#   i.e., deterministic. (pynative)"
# "The seed value is very significant in computer security to pseudo-randomly generate a secure secret encryption
#   key. (pynative)"

random.seed(a=None, version=2)
# Syntax; "It is the seed value. If the a is None, then by default, current system time is used.
#   If the operating system provides randomness sources, they are used instead of the system time.
#   For example, On windows, the os.urandom() internally uses CryptGenRandom() to generate random data.
#   If you pass a seed value in the form of an integer, it is used as it is. (pynative)"



# reference: From https://pynative.com/python-random-seed/ -> (pynative)
# i know bibliographies belong on the bottom, but it's easier to read, this way.

# i looked up os.urandom() as deterministic, on Google, and stackoverflow gave me this, as the top answer.

# "You can read up on the distinction of cryptographically secure RNG in this fantastic answer over at Crypto.SE.
#   The main distinction between random and the system RNG like urandom is one of use cases. random implements
#   deterministic PRNGs. There are scenarios where you want exactly those. For instance when you have an algorithm with
#   a random element which you want to test, and you need those tests to be repeatable. In that case you want a
#   deterministic PRNG which you can seed.
# urandom.() on the other hand cannot be seeded and draws its source of entropy from many unpredictable sources, making
#   it more random.
# True random is something else yet and you'd need a physical source of randomness like something that measures atomic
#   decay; that is truly random in the physical sense, but usually overkill for most applications." - deceze♦

# From https://stackoverflow.com/questions/47514695/whats-the-difference-between-os-urandom-and-random#:~:text=urandom%20on%20the%20other%20hand,sources%2C%20making%20it%20more%20random.

# i took the advice to glimpse at Crypto.SE, and it gave me a bunch of nerdy definitions, over-conceptualizing the
#   word, "random." what was useful?

# "There is no known method to predict decay so, yes, that is by definition cryptographically secure. Such things are
#   considered true randomness, as opposed to the pseudo-randomness that we generate with our pseudo-random number
#   generators (algorithms).
# The caveat is that you have to use the true random source properly. For example, if one particle decays (on average)
#   every 30 nanoseconds and you write down the current time every time it happens, this number is not very random
#   because the time is ever-increasing and the next event will almost certainly be less than X nanoseconds after the
#   previous one. An attacker can guess the few possible values between 0 and X. Only the timing variation from each
#   decay event can be used, for example by taking the last digit of the nanosecond in which the particle decayed. That
#   would give a uniform distribution from 0 through 9, so a couple bits of entropy/randomness... if and only if your
#   clock is precise to that nanosecond and has no interruptions that an attacker could learn of, which might be hard
#   to verify.
# So while it's truly random, designing methods to extract the entropy from such sources is not necessarily intuitive
#   or easy. - Luc

# From https://crypto.stackexchange.com/questions/39186/what-does-it-mean-for-a-random-number-generator-to-be-cryptographically-secure/39188#39188

# back up to stackoverflow, there was also this little gem, from DoesData.
# "Python 3.6 introduces the new secrets module"

# following their hyperlink led me to, https://docs.python.org/3/library/secrets.html
# some of the highlights here, are as follows:

# "In particular, secrets should be used in preference to the default pseudo-random number generator in the random
#   module, which is designed for modelling and simulation, not security or cryptography...

# To be secure against brute-force attacks, tokens need to have sufficient randomness. Unfortunately, what is
#   considered sufficient will necessarily increase as computers get more powerful and able to make more guesses in a
#   shorter period. As of 2015, it is believed that 32 bytes (256 bits) of randomness is sufficient for the typical
#   use-case expected for the secrets module."

# So, it basically provides recipes to format your own personal passwords, to be kept on drive. but, given that this is
#   all hashed out, on a dynamic language case, there are programs out there that can write up everything commanded, in
#   reverse. a good rule of thumb, when it comes to coding. if you can't see it in binary, you're not really in control.
# We're all standing on someone else's life's work.

# back up to pynative's .seed() tutorial:

random.seed(a=None, version=2)
# Syntax; "version: If the version is set to 2 by default, str, bytes, or bytearray object gets converted to an int,
#   and all of its bits are used. (pynative)"

# The rest of this page, explains that random function should be sequenced together, in order to form a more complex
#   algorithm.

# random.seed() example:

import random

print('Random number with seed 30')
for i in range(3):
    # Random number with seed 30
    random.seed(30)
    print(random.randint(25, 50))

# Output:
# Random number with seed 30
# 42
# 42
# 42
# (pynative)

# system time .seed() example:

import random
from datetime import datetime

# Random number with system time
random.seed(datetime.now())
print("Random Number", random.randint(25, 50))
# Output 50
# (pynative)
# it should print -> Random Number 50

# alternative to custom .seed(), in order to save the outcome.

import random
import sys

# create a seed
seed_value = random.randrange(sys.maxsize)
# save this seed somewhere. So if you like the result you can use this seed to reproduce it
print('Seed value:', seed_value)
# Output 4542355562136458828
#(pynative)
# it should print -> Seed value: 4542355562136458828

# Now, Seed the random number generator
random.seed(seed_value)
num = random.randint(10, 500)
print("Random Number", num)
# Output 404
#(pynative)
# it should print -> Random Number 404
# this means that random.randint(10, 500) seeded with 4542355562136458828, gives us 404, followed by a deterministic
#   number set.

# .seed() with .randrange()

import random

# Random seed with randrange
random.seed(350)
print(random.randrange(300, 500))
# output 336

random.seed(350)
print(random.randrange(300, 500))
# Output 336
# (pynative)
# same seed = same species

# .seed() with .choice()

import random
names = ["Alex", "Emma", "Kelly", "Scott", "Jessa"]

random.seed(50)
random_item = random.choice(names)
print ("First random name from list ", random_item)
# output scott

random.seed(50)
random_item = random.choice(names)
print ("Second random name from list ", random_item)
# output Scott
# (pynative)
# it should print out -> First random name from list Scott
# then, -> Second random name from list Scott

# .seed() with .sample(sample_list, #_of_samples_taken)

import random

# using random.seed() and random.sample() together
fruit_list = ["Apple", "Mango", "Banana", "Apricot", "Cherries", "Grape", "Kiwi"]

random.seed(3)
sample_list = random.sample(fruit_list, 3)
print("First sample fruit list ", sample_list)
# Output ['Mango', 'Cherries', 'Grape']

random.seed(3)
sample_list = random.sample(fruit_list, 3)
print("Second sample fruit list ", sample_list)
# output ['Mango', 'Cherries', 'Grape']
# (pynative)
# it should print out -> First sample fruit list ['Mango, 'Cherries, 'Grape']
# then, -> Second sample fruit list ['Mango', 'Cherries', 'Grape']

# .seed() with .shuffle(list)

import random

numbers = [10, 20, 30, 40, 50, 60]
print("Original list: ", numbers)
random.seed(4)
random.shuffle(numbers)
print("Shuffled list ", numbers)
# Output [40, 60, 50, 10, 30, 20]

random.seed(4)
random.shuffle(numbers)
print("Reshuffled list ", numbers)
# Output [40, 60, 50, 10, 30, 20]
# (pynative)
# it should read -> Original list: [10, 20, 30, 40, 50, 60]
# followed by, -> Shuffled list [40, 60, 50, 10, 30, 20]
# then, -> Reshuffled list [40, 60, 50, 10, 30, 20]
# Shuffled list and Reshuffled list are the same output, because the seed is consistent.